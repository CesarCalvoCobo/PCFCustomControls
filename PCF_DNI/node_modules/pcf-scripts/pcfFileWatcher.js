"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const validate_task_1 = require("./tasks/validate.task");
const manifestTypes_task_1 = require("./tasks/manifestTypes.task");
const output_task_1 = require("./tasks/output.task");
const chokidar = require('chokidar');
const constants = require("./constants");
const path = require("path");
class PCFFileWatcher {
    constructor() {
        this._isReady = false;
    }
    // Returning promise is resolved only when watcher is ready. Mainly needed for testing purposes.
    start(context, watchBehavior) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const pathsToWatch = yield this.getPathsToWatch(context);
                return new Promise((resolve, reject) => {
                    this._watcher = chokidar.watch(pathsToWatch, { awaitWriteFinish: {
                            stabilityThreshold: 2000,
                            pollInterval: 100
                        } })
                        .on('ready', () => {
                        this._isReady = true;
                        return resolve('watch is now ready');
                    })
                        .on('change', () => {
                        if (!this._isReady) {
                            return;
                        }
                        if (watchBehavior) {
                            watchBehavior(context);
                        }
                        else {
                            this.recompileWatchedFiles(context).catch(() => context.getDiagnostic().flush(true));
                        }
                    });
                });
            }
            catch (error) {
                context.getDiagnostic().flush(true);
            }
        });
    }
    getPathsToWatch(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const pathsToWatch = [];
            return context.mapControls((control) => {
                const manifestPath = path.resolve(control.getControlPath(), constants.MANIFEST_INPUT_FILE_NAME);
                pathsToWatch.push(manifestPath);
                let resourcePaths = control.getControlManifest().getResources(true);
                for (let resourcePath of resourcePaths) {
                    pathsToWatch.push(path.resolve(control.getControlPath(), resourcePath));
                }
                return Promise.resolve(pathsToWatch);
            });
        });
    }
    recompileWatchedFiles(context) {
        return __awaiter(this, void 0, void 0, function* () {
            let diag = context.getDiagnostic();
            context.getDiagnostic().clear();
            return context.mapControls((control) => {
                return Promise.resolve(control.reloadManifest(diag));
            }).then(() => __awaiter(this, void 0, void 0, function* () {
                const validateManifestTask = new validate_task_1.ValidateManifestTask;
                const generateManifestTypesTask = new manifestTypes_task_1.GenerateManifestTypesTask;
                const createOutputTask = new output_task_1.CreateOutputTask;
                yield validateManifestTask.run(context);
                yield generateManifestTypesTask.run(context);
                yield createOutputTask.run(context);
            }));
        });
    }
    stop() {
        if (!this._watcher) {
            return;
        }
        this._watcher.close();
    }
}
exports.PCFFileWatcher = PCFFileWatcher;
